use proc_macro::TokenStream;
use quote::{format_ident, quote};
use syn::parse::{Parse, ParseStream};
use syn::{parse_macro_input, Ident, Lit, Token};
use syn::Expr;

use uuid::Uuid;

use rml_core::{AbstractValue, ItemTypeEnum, Property, RmlEngine};

#[proc_macro]
pub fn rml(input: TokenStream) -> TokenStream {
    let parsed = parse_macro_input!(input as RmlNode);
    let generated = parsed.generate();
    //let generated_id = generated.0;
    let generated_node = generated.1;
    let generated_functions = generated.2;
    let generated_initializer = generated.3;

    //println!("Initializer functions: {:#?}", generated_initializer_functions); // initializer_functions

    let result = quote! {
        {
            // rml engine generated by rml macro
            let mut engine = RmlEngine::new();
            #generated_node; // tree added here
            #generated_functions // functions are added after the tree is built

            // // initializer functions are added here
            #generated_initializer

            engine
        }
    };
    TokenStream::from(result)
}

enum Value {
    Lit(Lit),
    Ident(Ident),
    Block(syn::Block),
}

fn lit_to_string(literal: &Lit) -> Option<String> {
    match literal {
        Lit::Str(lit_str) => Some(lit_str.value()), // Extract the value from a LitStr
        Lit::ByteStr(lit_byte_str) => {
            Some(String::from_utf8_lossy(&lit_byte_str.value()).to_string())
        }
        Lit::Char(lit_char) => Some(lit_char.value().to_string()),
        Lit::Int(lit_int) => Some(lit_int.base10_digits().to_string()), // Convert integer to its string representation
        Lit::Float(lit_float) => Some(lit_float.base10_digits().to_string()), // Convert float to its string representation
        Lit::Bool(lit_bool) => Some(lit_bool.value.to_string()), // Convert boolean to "true" or "false"
        Lit::Byte(lit_byte) => Some(format!("{:?}", lit_byte.value())), // Convert byte to a string
        // Add additional cases if needed for other literal types.
        _ => None, // If it's an unsupported literal type
    }
}

// fn value_to_property(value: &Value) -> Property {
//     match value {
//         Value::Lit(literal) => match literal {
//             Lit::Str(lit_str) => Property::new(AbstractValue::String(lit_str.value())),
//             Lit::ByteStr(lit_byte_str) => {
//                 Property::new(AbstractValue::String(String::from_utf8_lossy(&lit_byte_str.value()).to_string()))
//             }
//             Lit::Char(lit_char) => Property::new(AbstractValue::String(lit_char.value().to_string())),
//             Lit::Int(lit_int) => {
//                 let number: f32 = lit_int.base10_parse().unwrap_or_default();
//                 Property::new(AbstractValue::Number(number))
//             }
//             Lit::Float(lit_float) => {
//                 let number: f32 = lit_float.base10_parse().unwrap_or_default();
//                 Property::new(AbstractValue::Number(number))
//             }
//             Lit::Bool(lit_bool) => Property::new(AbstractValue::Bool(lit_bool.value)),
//             Lit::Byte(lit_byte) => Property::new(AbstractValue::Number(lit_byte.value() as f32)),
//             _ => Property::new(AbstractValue::Null), // Handle unexpected or unsupported literal types
//         },
//         Value::Ident(ident) => Property::new(AbstractValue::String(ident.to_string())),
//     }
// }

fn value_to_abstract_value(value: &Value) -> AbstractValue {
    match value {
        Value::Lit(literal) => match literal {
            Lit::Str(lit_str) => AbstractValue::String(lit_str.value()),
            Lit::ByteStr(lit_byte_str) => {
                AbstractValue::String(String::from_utf8_lossy(&lit_byte_str.value()).to_string())
            }
            Lit::Char(lit_char) => AbstractValue::String(lit_char.value().to_string()),
            Lit::Int(lit_int) => {
                let number: f32 = lit_int.base10_parse().unwrap_or_default();
                AbstractValue::Number(number)
            }
            Lit::Float(lit_float) => {
                let number: f32 = lit_float.base10_parse().unwrap_or_default();
                AbstractValue::Number(number)
            }
            Lit::Bool(lit_bool) => AbstractValue::Bool(lit_bool.value),
            Lit::Byte(lit_byte) => AbstractValue::Number(lit_byte.value() as f32),
            _ => AbstractValue::Null, // Handle unexpected or unsupported literal types
        },
        Value::Ident(ident) => AbstractValue::String(ident.to_string()),
        Value::Block(_block) => {
            // Handle block values if needed
            AbstractValue::Null // Placeholder for block handling
        }
    }
}

impl ToString for Value {
    fn to_string(&self) -> String {
        match self {
            Value::Lit(literal) => lit_to_string(literal).unwrap_or_default(),
            Value::Ident(ident) => ident.to_string(),
            Value::Block(_) => "<block>".to_string(),
        }
    }
}

fn inject_engine_in_block(mut block: syn::Block, initializer: bool) -> syn::Block {
    use syn::{Expr, ExprCall, ExprPath, Stmt, Token};

    block.stmts = block
        .stmts
        .into_iter()
        .map(|stmt| match stmt {
            Stmt::Expr(expr, semi_opt) => {
                let expr = match expr {
                    Expr::Call(mut call) => {
                        // Si ce n’est pas déjà "engine" en premier argument
                        let has_engine = call.args.iter().any(|arg| {
                            matches!(arg, Expr::Path(p) if p.path.is_ident("engine"))
                        });

                        //println!("Has engine: {:?}", has_engine);

                        if !has_engine {
                            if initializer {
                                let engine_expr: Expr = syn::parse_quote!(&mut engine);
                                call.args.insert(0, engine_expr);
                            }
                            else {
                                let engine_expr: Expr = syn::parse_quote!(engine);
                                call.args.insert(0, engine_expr);
                            }
                        }

                        Expr::Call(call)
                    }
                    other => other,
                };
                Stmt::Expr(expr, semi_opt)
            }
            other => other,
        })
        .collect();

    block
}

fn inject_engine_in_caller(mut block: syn::Block, functions_name: &[String]) -> syn::Block {
    use syn::{Expr, Stmt};

    println!("Injecting engine in caller block, functions: {:?}", functions_name);

    block.stmts = block
    .stmts
    .into_iter()
    .map(|stmt| match stmt {
        Stmt::Expr(expr, semi_opt) => {
            //println!("Expr ! {:?}", quote! {#expr });
            let new_expr = inject_engine_in_expr(expr, functions_name);
            Stmt::Expr(new_expr, semi_opt)
        }
        Stmt::Local(local) => Stmt::Local(local),
        Stmt::Item(item) => Stmt::Item(item),
        other => other,
    })
    .collect();

block

}
fn inject_engine_in_expr(expr: Expr, functions_name: &[String]) -> Expr {
    use syn::Expr::*;
    
    match expr {
        MethodCall(mut method_call) => {
            let method_name = method_call.method.to_string();
    
            if functions_name.iter().any(|name| name == &method_name) {
                let has_engine = method_call.args.iter().any(|arg| {
                    matches!(arg, Expr::Path(p) if p.path.is_ident("engine"))
                });
    
                if !has_engine {
                    let engine_expr: Expr = syn::parse_quote!(engine);
                    method_call.args.insert(0, engine_expr);
                }
            }
    
            // Appliquer récursivement sur les arguments
            method_call.args = method_call
                .args
                .into_iter()
                .map(|arg| inject_engine_in_expr(arg, functions_name))
                .collect();
    
            MethodCall(method_call)
        }
    
        Call(mut call_expr) => {
            call_expr.args = call_expr
                .args
                .into_iter()
                .map(|arg| inject_engine_in_expr(arg, functions_name))
                .collect();
            call_expr.func = Box::new(inject_engine_in_expr(*call_expr.func, functions_name));
            Call(call_expr)
        }
    
        Let(mut let_expr) => {
            let_expr.expr = Box::new(inject_engine_in_expr(*let_expr.expr, functions_name));
            Let(let_expr)
        }
    
        Block(mut block_expr) => {
            block_expr.block = inject_engine_in_caller(block_expr.block, functions_name);
            Block(block_expr)
        }
    
        If(mut if_expr) => {
            if_expr.cond = Box::new(inject_engine_in_expr(*if_expr.cond, functions_name));
            if_expr.then_branch = inject_engine_in_caller(if_expr.then_branch, functions_name);
            if let Some((else_token, else_expr)) = if_expr.else_branch {
                let new_else = Box::new(inject_engine_in_expr(*else_expr, functions_name));
                if_expr.else_branch = Some((else_token, new_else));
            }
            If(if_expr)
        }
    
        _ => expr, // tous les autres types : inchangés
    }
    
    }

/// Struct to parse a Node
struct RmlNode {
    _ident: Ident, // unused directly, but allow to parse the node name and syntax
    properties: Vec<(Ident, Value)>,
    children: Vec<RmlNode>,
    functions: Vec<syn::ItemFn>,
}

impl Parse for RmlNode {
    /// Parse a `RmlNode` from a proc-macro input stream.
    ///
    /// We expect a sequence of tokens that looks like this:
    ///
    /// Node {
    ///     id: root
    ///     width: 200
    ///     height: 200

    ///     Rectangle {
    ///         x: 50
    ///         width: 100
    ///         height: 100
    ///         color: "green"
    ///     }
    /// }
    ///
    /// The parser will return an error if it encounters any other token.
    fn parse(input: ParseStream) -> syn::Result<Self> {
        // get the name of the node (Node ou Rectangle)
        let _ident: Ident = input.parse()?;

        // manage braces
        let content;
        syn::braced!(content in input);

        let mut properties = Vec::new();
        let mut children = Vec::new();
        let mut functions = Vec::new();

        // println!("Parsing node: {}", _ident);

        while !content.is_empty() {
            // check if we have a function
            if content.peek(Token![fn]) {
                let item: syn::Item = content.parse()?;
                if let syn::Item::Fn(func) = item {
                    //println!("Found function: {}", func.sig.ident);
                    // print the string representation of the function
                    // println!("{}", quote! { #func });
                    functions.push(func);
                } else {
                    return Err(content.error("Expected function"));
                }
            }
            else if content.peek(Ident) && content.peek2(Token![:]) {
                // read a property
                let key: Ident = content.parse()?;
                content.parse::<Token![:]>()?;

                let value: Value;
                if content.peek(Lit) {
                    value = Value::Lit(content.parse()?);
                } else if content.peek(Ident) {
                    value = Value::Ident(content.parse()?);
                } else if content.peek(syn::token::Brace) {
                    let block: syn::Block = content.parse()?;
                    value = Value::Block(block);
                } else {
                    return Err(content.error("Expected literal, identifier or block"));
                }
                content.parse::<Token![,]>().ok(); // optional virgule
                properties.push((key, value));
            } else if content.peek(Ident) {
                // we have a child
                let child: RmlNode = content.parse()?;
                children.push(child);
            } else {
                return Err(content.error("Unexpected token"));
            }
        }

        Ok(Self {
            _ident,
            properties,
            children,
            functions,
        })
    }
}

type GenResult = (String, proc_macro2::TokenStream, proc_macro2::TokenStream, proc_macro2::TokenStream);

impl RmlNode {
    fn generate(&self) -> GenResult {
        // use _ident to get the node type
        let node_type = self._ident.to_string();

        let node_type = match node_type.as_str() {
            "Node" => ItemTypeEnum::Node,
            "Rectangle" => ItemTypeEnum::Rectangle,
            "Text" => ItemTypeEnum::Text,
            _ => panic!("Unknown node type: {}", node_type),
        };
        
        // use or generate id if not present
        let id = self
            .properties
            .iter()
            .find_map(|(k, v)| if k == "id" { Some(v.to_string()) } else { None })
            .unwrap_or_else(|| Uuid::new_v4().simple().to_string());

        // Generate a temporary variable for the node
        let temp_node = format_ident!("temp_node_{}", id);

        // generate code for each child
        let child_results: Vec<GenResult> = self
            .children
            .iter()
            .map(|child| child.generate())
            .collect();

        // get token stream parts
        let child_code: Vec<proc_macro2::TokenStream> = child_results
            .iter()
            .map(|(_, code, _, _)| code.clone())
            .collect();

        // get temporary variable names
        let child_temp_nodes: Vec<proc_macro2::TokenStream> = child_results
            .iter()
            .map(|(id, _, _, _)| {
                let child_temp_var = format_ident!("temp_node_{}", id);
                quote! { #child_temp_var }
            })
            .collect();

        // get functions code
        let functions_of_childs: Vec<proc_macro2::TokenStream> = child_results
            .iter()
            .map(|(_, _, functions, _)| functions.clone())
            .collect();

        let initializer_of_childs: Vec<proc_macro2::TokenStream> = child_results
            .iter()
            .map(|(_, _, _, initializer)| initializer.clone())
            .collect();

        // generate initializer functions
        let initializer: Vec<proc_macro2::TokenStream> = self
            .properties
            .iter()
            .map(|(k, v)| {
                let k_string = k.to_string();
                // callbacks
                if !k_string.starts_with("on_") && !k_string.ends_with("_changed") {
                    // test if the property is a block code or a value
                    let value = match v {
                        Value::Block(block) => {
                            //let modified_block = inject_engine_in_block(block.clone(), true);
                            let modified_block = block; //inject_engine_in_caller(block.clone(), &functions_name);
                            println!("Modified property block: {:?}", quote! { #modified_block }.to_string());
                            quote! {
                                // create AbstractValue from the value
                                let value: AbstractValue = #modified_block .into();
                                let prop_id = engine.add_property(Property::new( value ));
                                engine.add_property_to_node(#temp_node, stringify!(#k).to_string() , prop_id);
                            }
                        }
                        _ => {
                            quote! {}   
                        }
                    };

                    value
                }
                else {
                    quote! {}
                }
            }).collect();

        let initializer_code = quote! {
            #(#initializer)*
            #(#initializer_of_childs)*
        };

        // generate code for each function
        let functions: Vec<proc_macro2::TokenStream> = self
            .functions
            .iter()
            .map(|f| {
                let f_name = f.sig.ident.clone();
                let f_inputs = f.sig.inputs.clone();
                let f_output = f.sig.output.clone();
                let f_body = inject_engine_in_block((*f.block).clone(), false);

                let res = match f_output {
                    syn::ReturnType::Default => {
                        quote! {
                            //#f
                            fn #f_name(engine: &mut RmlEngine, #f_inputs) #f_body
                        }
                    }
                    _ => {
                        quote! {
                            //#f
                            fn #f_name(engine: &mut RmlEngine, #f_inputs) #f_output
                            #f_body
                        }
                    }
                };
                //println!("Function code: {}", quote! {#res});
                res
                
            })
            .collect();

        let functions_name: Vec<String> = self.functions
            .iter()
            .map(|f| f.sig.ident.to_string())
            .collect();

        let functions_code = quote! {
            #(#functions)*
            #(#functions_of_childs)*
        };

        // convert properties in token stream
        let properties: Vec<proc_macro2::TokenStream> = self
            .properties
            .iter()
            .map(|(k, v)| {
                let k_string = k.to_string();
                // callbacks
                if k_string.starts_with("on_") && k_string.ends_with("_changed") {
                    let observed = k_string.trim_start_matches("on_").trim_end_matches("_changed");
                    if let Value::Block(block) = v {
                        // in block, if we see a call to a function, we need to add the engine as first argument to the function
                        //let modified_block = inject_engine_in_block(block.clone(), false);
                        let modified_block = block;//inject_engine_in_caller(block.clone(), &functions_name);
                        println!("Modified callback block: {:?}", quote! { #modified_block }.to_string());
                        quote! {
                            let cb_id = engine.add_callback( |engine| #modified_block );
                            engine.bind_node_property_to_callback( #id, #observed, cb_id );
                        }
                    } else {
                        quote! {} // fallback ou erreur
                    }
                } 
                // normal prop
                else {
                    // test if the property is a block code or a value
                    let value = match v {
                        Value::Block(block) => {
                            //let modified_block = inject_engine_in_block(block.clone(), true);
                            let modified_block = block; //inject_engine_in_caller(block.clone(), &functions_name);
                            println!("Modified property block: {:?}", quote! { #modified_block }.to_string());
                            quote! {
                                // create AbstractValue from the value
                                let value: AbstractValue = #modified_block .into();
                                let prop_id = engine.add_property(Property::new( value ));
                                engine.add_property_to_node(#temp_node, stringify!(#k).to_string() , prop_id);
                            }
                        }
                        _ => {
                            let value = value_to_abstract_value(v);
                            quote! {
                                let prop_id = engine.add_property(Property::new( #value ));
                                engine.add_property_to_node(#temp_node, stringify!(#k).to_string() , prop_id);
                            }   
                        }
                    };

                    value
                }
            }).collect();

        // generate current node
        let node_code = quote! {
            let #temp_node = engine.add_node(
                #id.to_string(),
                #node_type,
                HashMap::new(),
            ).unwrap();

            #(#properties)*

            #(
                #child_code;
                engine.add_child(#temp_node, #child_temp_nodes);
            )*
        };

        (id, node_code, functions_code, initializer_code)
    }
}
